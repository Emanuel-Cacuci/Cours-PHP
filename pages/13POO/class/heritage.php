<?php

namespace App;

?>

<h1>Cour sur l'heritage des classes en PHP</h1>

<h3>H√©ritage c'est quoi ?</h3>

<p>L'h√©ritage permet √† une classe d'h√©riter des propri√©t√©s et m√©thodes d'une classe.</p>

<h4>Exemple : </h4>


<?php

class Animal{
    public function respirer() : void{
        echo "Je respire dans l'air <br>";
    }
}

class Chien extends Animal {

    public function aboyer() : void{
        echo "Ouaf ouaf <br>";
    }
}

class Chat{
    public function mioler() : void{
        echo "Miaou <br>";
    }
}

$chien1=new Chien();
$chien1->respirer();
$chien1->aboyer();

?>

<h2>Redefini une m√©thode (Override)</h2>

<?php

class Poisson extends Animal{

    // cas 1 redefinition complete de la m√©thode (on ecrase la version parente que sur la class Poisson)
    
    public function respirer() : void{

        echo "Je respire de l'eau";
    }

}

class Reptil extends Animal{

    // cas 2 on utilise le parent:: respirer() pour remplacer la version du parent

    public function respirer() : void {
        // on appelle d'abord la m√©thode du parent (Animal)
        parent::respirer();
        // puis on ajoute une phrase personalis√©e
        echo "et dans l'eau ! <br>";
    }

}

// quand on veut conserver la logique parent et l'enrichire : ajouter un comportement par exemple, on utilise parent::
// quand on veut totalment changer la logique du parent : on ecrase la version parent on utilise pas parent::

$reptil=new Reptil();
$reptil->respirer();

class Vehicule{

    public string $marque="sans nom";
    protected int $vitesse=0;
    private string $moteur="sans moteur";


    public function getMoteur() : string {
        return $this->moteur;
    }

    public function setMoteur(string $moteur) :string {
        return $this->moteur = $moteur;
    }

    public function accelerer() : void {

        $this->vitesse += 10;
        echo "Vitesse actuelle : {$this->vitesse} km/h<br>";        

    }
}

class Voiture extends Vehicule{

    public function turbo() : void {

        $this->vitesse += 50;
        echo "Vitesse actuelle apres turbo : {$this->vitesse} km/h<br>";
    }

    public function creerMoteur(string $moteur) :?string {
        return $this->setMoteur($moteur);
    }

    public function afficherMoteur() : void {
        echo "Moteur : {$this->getMoteur()}<br>"; // comme moteur est en private on doit passer par le getter
    }
}

$voiture1=new Voiture();
 echo $voiture1->creerMoteur("Essence <br>");
 $voiture1->accelerer();
 $voiture1->turbo();

?>

<h2>Abstract class</h2>

<p>une class abstraite ne peut pas √™tre instanci√©e directement.</p>
<p>Elle sert de mod√©le aux classes qui l'etendent. Elle peut contenir des m√©thodes abstraites (√† d√©finir obligatoirement)</p>

<p>Elle sert de model de basse et peut contenir :</p>

<ul>
    <li>Des m√©thodes normales avec du code</li>
    <li>des m√©thodes abstraites sans corps</li>
</ul>

<?php

abstract class Animals {
    protected string $nom;
 
    public function __construct(string $nom) {
        $this->nom = $nom;
    }
 
    // M√©thode abstraite : aucune impl√©mentation ici
    abstract public function crier();
 
    // M√©thode normale : peut √™tre utilis√©e telle quelle
    public function sePresenter() {
        echo "Je suis un animal nomm√© $this->nom<br>";
    }
}
 
class Chiens extends Animals {
    public function crier() {
        echo "Ouaf Ouaf üê∂<br>";
    }
}
 
$rex = new Chiens("Rex");
$rex->sePresenter();
$rex->crier();

?>

<h2>Utilisation de final</h2>

<p>La mot-cl√© emp√©che la surcharge (redirection) d'une m√©thode.</p>
<p>Elle peut √™tre utilis√©e sur des classes, des m√©thodes, ou des propri√©t√©s.</p>
<p>Si au d√©but d'une classe il y a final, faire un h√©ritage de cette class est impossible, c'est la class final sans enfants possible</p>


<p>final class MaclassFinal, cr√©ation de la class final sans enfants possible</p> 


<p>class ClassEnfant extends MaclassFinal, on ne peut pas faire de h√©ritage de la class final, cela va donn√©e une erreur</p>

<p>Quand on d√©clare final dans une m√©thode, les classes qui h√©rite ne pourront pas r√©definir la m√©thode</p>


<p>Pourquoi utiliser final sur une m√©thode ?</p>

<ul>
    <li>Pour verrouiller un comportement sp√©cifique qui ne doit pas √™tre modifi√©</li>
    <li>Pour garantir la s√©curit√© des donn√©es</li>
    <li>Pour eviter les erreur et les abus d'heritage</li>
</ul>

<?php

class Employe

{

    protected string $nom;
 
    public function __construct(string $nom)

    {

        $this->nom = $nom;

    }
 
    final public function travailler()

    {

        echo "$this->nom travaille s√©rieusement.<br>";

    }

}
 
class Manager extends Employe

{

    // ‚ùå ERREUR ! On ne peut pas red√©finir une m√©thode final

    /*

    public function travailler() {

        echo "$this->nom travaille en dirigeant l'√©quipe.<br>";

    }

    */

    public function diriger()

    {

        echo "$this->nom dirige une √©quipe.<br>";

    }

}
 
$m = new Manager("Sophie");

$m->travailler(); // fonctionne

$m->diriger();
 
?>


<h2>Trait</h2>

// Un trait en PHP est une sorte de bloc de code r√©utilisable.
// Il permet de partager des m√©thodes ou propri√©t√©s entre plusieurs classes,
// sans avoir √† utiliser l'h√©ritage (extends).
//
// Contrairement √† une classe, un trait ne peut pas √™tre instanci√© directement.
// On l‚Äôutilise dans une classe avec le mot-cl√© "use".
//
// C‚Äôest tr√®s utile quand plusieurs classes ont des comportements identiques,
// mais qu‚Äôelles n‚Äôont pas de lien logique pour h√©riter d‚Äôune m√™me classe.
//
// Exemple :
//
// trait Logger {
//     public function log($message) {
//         echo "[LOG] " . $message;
//     }
// }
//
// class Utilisateur {
//     use Logger;
// }
//
// $u = new Utilisateur();
// $u->log("Utilisateur connect√©.");  // Affiche : [LOG] Utilisateur connect√©.
//
// Ce syst√®me permet de factoriser du code sans casser la hi√©rarchie objet.
 
 


?>